// server.js
// Codespace proxy server with extremely easy admin-token setup support.
// - If ADMIN_TOKEN is present in the environment, admin endpoints require it.
// - If ADMIN_TOKEN is NOT present, a one-time /api/setup endpoint is available to install a token
//   (it writes a .env file and sets the token in memory so you can configure without editing files).
// SECURITY NOTES:
// - The /api/setup endpoint is only enabled when no ADMIN_TOKEN is set in the environment.
// - The .env file written by /api/setup is placed in the server working directory. DO NOT commit it.
// - This convenience is for Codespaces / local testing. For any exposed/public service, use Codespaces secrets or other secret managers.

const express = require('express');
const { createProxyServer } = require('http-proxy');
const morgan = require('morgan');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const os = require('os');

require('dotenv').config();

let ADMIN_TOKEN = process.env.ADMIN_TOKEN || null; // current active token (in-memory)
const PORT = process.env.PORT ? parseInt(process.env.PORT) : 8080;

const app = express();
app.use(morgan('tiny'));
app.use(express.json());
app.use(cors()); // UI will call API from same Codespace URL

// In-memory configuration for this Codespace instance.
let config = {
  target: null // e.g. "https://example.com"
};

// Helper: persist a .env file with ADMIN_TOKEN (will overwrite .env)
function writeDotEnv(token, port = PORT) {
  const content = `# Auto-generated by server setup\nADMIN_TOKEN=${token}\nPORT=${port}\n`;
  fs.writeFileSync(path.join(process.cwd(), '.env'), content, { encoding: 'utf8', flag: 'w' });
}

// Info / status endpoint for UI
app.get('/api/info', (req, res) => {
  res.json({
    adminConfigured: Boolean(process.env.ADMIN_TOKEN || ADMIN_TOKEN),
    usingEnvAdminToken: Boolean(process.env.ADMIN_TOKEN),
    configuredTarget: !!config.target,
    target: config.target || null,
    canRunSetup: !Boolean(process.env.ADMIN_TOKEN) && !ADMIN_TOKEN, // only allow setup if nothing set
    note: 'If admin is not configured, you can POST /api/setup to create a .env with ADMIN_TOKEN (one-time). See UI.'
  });
});

// One-time setup endpoint (only available if no ADMIN_TOKEN is present in env or memory).
// It creates a .env file with the provided token and loads it into process memory.
// WARNING: This endpoint is intentionally permissive only when admin is NOT configured.
// Once admin is configured (via env, fallback, or setup), this endpoint rejects calls.
app.post('/api/setup', (req, res) => {
  if (process.env.ADMIN_TOKEN || ADMIN_TOKEN) {
    return res.status(403).json({
      error: 'already_configured',
      message: 'Admin token already configured. /api/setup is only allowed before initial configuration.'
    });
  }
  const { newToken } = req.body || {};
  if (!newToken || typeof newToken !== 'string' || newToken.length < 16) {
    return res.status(400).json({
      error: 'invalid_token',
      message: 'Provide a newToken string of sufficient length (min 16 chars).'
    });
  }

  try {
    // Persist .env and set in-memory ADMIN_TOKEN so server can use it immediately.
    writeDotEnv(newToken, PORT);
    // update process.env and in-memory token so no restart needed
    process.env.ADMIN_TOKEN = newToken;
    ADMIN_TOKEN = newToken;
    console.log('Admin token created via /api/setup and saved to .env (DO NOT COMMIT .env).');
    return res.json({
      message: 'admin_token_created',
      note: 'A .env file was written in the server directory and the token is now active in memory.'
    });
  } catch (e) {
    console.error('Failed to write .env', e);
    return res.status(500).json({ error: 'write_failed', message: 'Failed to write .env: ' + e.message });
  }
});

// Middleware: require the current admin token
function requireAdminToken(req, res, next) {
  const active = process.env.ADMIN_TOKEN || ADMIN_TOKEN;
  if (!active) {
    return res.status(503).json({
      error: 'admin_token_not_set',
      message: 'ADMIN_TOKEN is not set on the server. Use /api/setup or set ADMIN_TOKEN and restart.'
    });
  }

  const header = req.get('x-admin-token') || req.get('authorization');
  if (!header) return res.status(401).json({ error: 'missing_token', message: 'Missing x-admin-token or Authorization header.' });
  const token = header.startsWith('Bearer ') ? header.slice(7) : header;
  if (token !== active) return res.status(403).json({ error: 'invalid_token', message: 'Provided token is invalid.' });
  next();
}

function validateHttpUrl(str) {
  try {
    const u = new URL(str);
    return u.protocol === 'http:' || u.protocol === 'https:';
  } catch {
    return false;
  }
}

// Set the upstream target for this proxy instance (admin only)
app.post('/api/config', requireAdminToken, (req, res) => {
  const { target } = req.body;
  if (!target || !validateHttpUrl(target)) {
    return res.status(400).json({ error: 'invalid_target', message: 'Invalid or missing target. Must be a full http(s) URL.' });
  }
  config.target = target;
  console.log(`Configured proxy target => ${target}`);
  res.json({
    message: 'target set',
    proxyPath: '/p/',
    target
  });
});

// Check status (admin only)
app.get('/api/status', requireAdminToken, (req, res) => {
  res.json({
    configured: !!config.target,
    target: config.target || null
  });
});

// Static frontend
app.use('/', express.static(path.join(__dirname, 'public')));

// Proxying handler - only allow proxying if config.target is set.
const proxy = createProxyServer({});
proxy.on('error', (err, req, res) => {
  console.error('Proxy error', err && err.message);
  if (!res.headersSent) {
    res.writeHead(502, { 'Content-Type': 'application/json' });
  }
  try {
    res.end(JSON.stringify({ error: 'proxy_error', message: err && err.message }));
  } catch (e) {
    // ignore
  }
});

app.use('/p', (req, res) => {
  const active = process.env.ADMIN_TOKEN || ADMIN_TOKEN;
  if (!active) {
    return res.status(503).json({
      error: 'admin_token_not_set',
      message: 'Proxying is disabled because ADMIN_TOKEN is not set on the server. Use /api/setup or set ADMIN_TOKEN and restart.'
    });
  }
  if (!config.target) {
    return res.status(404).json({
      error: 'no_target_configured',
      message: 'No upstream target configured. Use POST /api/config with header x-admin-token: <ADMIN_TOKEN>.'
    });
  }

  const originalPath = req.originalUrl.replace(/^\/p/, '') || '/';
  const targetUrl = new URL(config.target);
  let combinedPath = '';
  if (targetUrl.pathname && targetUrl.pathname !== '/') {
    combinedPath += targetUrl.pathname.replace(/\/$/, '');
  }
  combinedPath += originalPath;
  const proxyTarget = `${targetUrl.protocol}//${targetUrl.host}${combinedPath}`;

  proxy.web(req, res, { target: proxyTarget, changeOrigin: true, selfHandleResponse: false });
});

// Fallback route
app.use((req, res) => {
  res.status(404).json({ error: 'not_found' });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Codespace proxy server listening on port ${PORT}`);
  if (process.env.ADMIN_TOKEN) {
    console.log('ADMIN_TOKEN is set via environment. Admin endpoints are enabled.');
  } else {
    console.log('No ADMIN_TOKEN was found in environment. You may create one with POST /api/setup from the UI or terminal.');
    console.log('After creating the token, a .env will be written and the token is active in-memory (no restart required).');
  }
});
